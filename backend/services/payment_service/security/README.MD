# Payment Security Core Module

## üìã Overview

Comprehensive security module for PCI-DSS compliant payment processing with advanced fraud detection, encryption, and 3D Secure authentication.

## üèóÔ∏è Architecture

```
security/
‚îú‚îÄ‚îÄ __init__.py                 # Module initialization
‚îú‚îÄ‚îÄ tokenization.py             # üîê Card tokenization (PCI DSS)
‚îú‚îÄ‚îÄ hsm_client.py              # üîí AWS KMS/CloudHSM integration
‚îú‚îÄ‚îÄ fraud_detection.py         # ü§ñ ML fraud scoring + rules
‚îú‚îÄ‚îÄ pci_auditor.py            # üìã PCI-DSS compliance checks
‚îú‚îÄ‚îÄ three_d_secure.py         # üõ°Ô∏è 3D Secure flows (3DS2/SCA)
‚îú‚îÄ‚îÄ encryption.py             # üîê Field-level encryption
‚îî‚îÄ‚îÄ README.md                 # This file
```

## üöÄ Quick Start

### Installation

```bash
pip install cryptography boto3
```

### Basic Usage

```python
from security import (
    card_tokenizer,
    fraud_detector,
    three_d_secure,
    field_encryption
)

# 1. Tokenize card
token_result = card_tokenizer.generate_token(
    card_number="4532015112830366",
    cvv="123",
    expiry="12/25",
    cardholder_name="JOHN DOE"
)

# 2. Check fraud
fraud_result = fraud_detector.calculate_fraud_score({
    'amount': 250.00,
    'card_fingerprint': token_result['fingerprint'],
    'ip_address': '123.45.67.89'
})

# 3. Encrypt data
encrypted = field_encryption.encrypt_field("sensitive_data")
```

## üì¶ Modules

### 1. Card Tokenization (`tokenization.py`)

**Purpose**: Convert sensitive card data into secure tokens (PCI-DSS Requirement 3.4)

**Features**:
- ‚úÖ Luhn algorithm validation
- ‚úÖ Secure token generation (cryptographically random)
- ‚úÖ Card brand detection (Visa, Mastercard, Amex, Discover)
- ‚úÖ PAN masking (show only last 4 digits)
- ‚úÖ Card fingerprinting
- ‚úÖ Token expiration (1 hour default)

**Usage**:
```python
from security import card_tokenizer

# Generate token
result = card_tokenizer.generate_token(
    card_number="4532015112830366",
    cvv="123",
    expiry="12/25",
    cardholder_name="JOHN DOE"
)

# Result:
# {
#     'token': 'tok_xxxxx',
#     'masked_card': '************0366',
#     'card_brand': 'Visa',
#     'fingerprint': 'abc123def456'
# }

# Detokenize (when needed for processing)
original = card_tokenizer.detokenize(result['token'])
```

### 2. HSM/KMS Integration (`hsm_client.py`)

**Purpose**: Hardware Security Module integration via AWS KMS

**Features**:
- ‚úÖ Master key creation & management
- ‚úÖ AES-256 encryption/decryption
- ‚úÖ Data key generation (envelope encryption)
- ‚úÖ Automatic key rotation
- ‚úÖ Encryption context (AEAD)

**Usage**:
```python
from security import hsm_client

# Encrypt with KMS
ciphertext = hsm_client.encrypt_data(
    plaintext="4532015112830366",
    key_id="your-kms-key-id",
    context={'data_type': 'card_number'}
)

# Decrypt
plaintext = hsm_client.decrypt_data(
    ciphertext=ciphertext,
    key_id="your-kms-key-id",
    context={'data_type': 'card_number'}
)
```

### 3. Fraud Detection (`fraud_detection.py`)

**Purpose**: ML-based fraud scoring with real-time risk assessment

**Features**:
- ‚úÖ Multi-factor risk scoring (0-100)
- ‚úÖ Velocity checking (transaction frequency)
- ‚úÖ Geographic anomaly detection
- ‚úÖ Device fingerprinting
- ‚úÖ Amount anomaly detection
- ‚úÖ Blacklist management
- ‚úÖ Risk level classification (SAFE, LOW, MEDIUM, HIGH, CRITICAL)

**Risk Factors**:
1. Transaction amount anomaly
2. High velocity (too many transactions)
3. Geographic impossible travel
4. Unusual transaction time
5. VPN/Proxy detection
6. New device usage
7. Blacklisted card

**Usage**:
```python
from security import fraud_detector

# Calculate fraud score
result = fraud_detector.calculate_fraud_score({
    'amount': 1500.00,
    'card_fingerprint': 'abc123',
    'location': {'country': 'US'},
    'ip_address': '123.45.67.89',
    'device_id': 'device_xyz'
})

# Result:
# {
#     'score': 45,
#     'risk_level': 'MEDIUM',
#     'factors': ['UNUSUAL_AMOUNT', 'NEW_DEVICE'],
#     'recommendation': 'MANUAL_REVIEW'
# }
```

### 4. PCI-DSS Auditor (`pci_auditor.py`)

**Purpose**: Automated PCI-DSS compliance checking

**Features**:
- ‚úÖ All 12 PCI-DSS requirements coverage
- ‚úÖ Automated audit trails
- ‚úÖ Storage configuration validation
- ‚úÖ Compliance scoring
- ‚úÖ Detailed reporting

**Key Requirements Checked**:
- Requirement 3: Protect stored cardholder data
- Requirement 4: Encrypt transmission
- Requirement 7: Restrict access
- Requirement 8: Unique IDs & authentication
- Requirement 10: Track & monitor access

**Usage**:
```python
from security import pci_auditor

# Run full audit
audit_result = pci_auditor.run_full_audit()

# Check storage compliance
storage_check = pci_auditor.check_card_data_storage({
    'stores_full_pan': False,
    'stores_cvv': False,
    'encryption_enabled': True
})

# Get compliance report
report = pci_auditor.get_compliance_report()
```

### 5. 3D Secure (`three_d_secure.py`)

**Purpose**: 3DS 2.0/SCA implementation for PSD2 compliance

**Features**:
- ‚úÖ 3DS 2.2.0 protocol support
- ‚úÖ Risk-based authentication (RBA)
- ‚úÖ Frictionless flow for low-risk transactions
- ‚úÖ Multiple challenge types (OTP SMS, Email, Biometric)
- ‚úÖ SCA exemptions (low-value, trusted beneficiary, TRA)
- ‚úÖ CAVV generation
- ‚úÖ Liability shift indication

**Flow Types**:
1. **Frictionless**: No challenge (low risk)
2. **Challenge**: OTP/Biometric verification (medium/high risk)

**Usage**:
```python
from security import three_d_secure

# Initiate authentication
auth_request = three_d_secure.initiate_authentication({
    'amount': 250.00,
    'merchant_id': 'MERCHANT_001',
    'email': 'customer@example.com',
    'transaction_id': 'TXN_123'
})

if auth_request['challenge_required']:
    # Send OTP
    three_d_secure.send_challenge_otp(
        auth_request['three_ds_session_id'],
        method='SMS'
    )
    
    # Verify response
    result = three_d_secure.verify_challenge(
        auth_request['three_ds_session_id'],
        challenge_response='123456'
    )
```

### 6. Field-Level Encryption (`encryption.py`)

**Purpose**: AES-256 encryption for sensitive data fields

**Features**:
- ‚úÖ AES-256-GCM (authenticated encryption)
- ‚úÖ Fernet encryption (AES-128 CBC + HMAC)
- ‚úÖ Context-based encryption (AEAD)
- ‚úÖ Key rotation support
- ‚úÖ Data masking utilities
- ‚úÖ Secure storage wrapper

**Usage**:
```python
from security import field_encryption, data_masking

# Encrypt single field
encrypted = field_encryption.encrypt_field(
    plaintext="4532015112830366",
    context={'data_type': 'card'}
)

# Decrypt
decrypted = field_encryption.decrypt_field(
    ciphertext=encrypted,
    context={'data_type': 'card'}
)

# Mask sensitive data
masked = data_masking.mask_card_number("4532015112830366")
# Output: "************0366"
```

## üîê Security Best Practices

### 1. **Never Store CVV/PIN**
```python
# ‚ùå WRONG
store_in_database(cvv="123")

# ‚úÖ CORRECT
# Only use CVV for real-time authorization, then discard
process_payment(cvv="123")  # Use immediately
# CVV is never stored
```

### 2. **Always Tokenize Cards**
```python
# ‚ùå WRONG
store_in_database(card_number="4532015112830366")

# ‚úÖ CORRECT
token = card_tokenizer.generate_token(...)
store_in_database(token=token['token'])
```

### 3. **Encrypt Stored Data**
```python
# ‚ùå WRONG
database.save(email="user@example.com")

# ‚úÖ CORRECT
encrypted_email = field_encryption.encrypt_field("user@example.com")
database.save(encrypted_email=encrypted_email)
```

### 4. **Mask Data in Logs**
```python
# ‚ùå WRONG
logger.info(f"Processing card: {card_number}")

# ‚úÖ CORRECT
masked = data_masking.mask_card_number(card_number)
logger.info(f"Processing card: {masked}")
```

## üéØ Complete Payment Flow

```python
from security import (
    card_tokenizer,
    fraud_detector,
    three_d_secure,
    field_encryption,
    pci_auditor
)

def process_secure_payment(payment_data):
    # 1. Tokenize
    token = card_tokenizer.generate_token(...)
    
    # 2. Fraud check
    fraud_result = fraud_detector.calculate_fraud_score(...)
    if fraud_result['risk_level'] == 'CRITICAL':
        return {'error': 'Transaction blocked'}
    
    # 3. 3DS authentication
    if fraud_result['recommendation'] == 'REQUIRE_3DS_VERIFICATION':
        auth_result = three_d_secure.initiate_authentication(...)
        if auth_result['challenge_required']:
            # Handle challenge (OTP/Biometric)
            pass  # Implement challenge handling
```

## Ch·∫°y test cho ph·∫ßn `security`

T√≥m t·∫Øt nhanh:
- Test d√πng pytest (unit + async).  
- ƒê·∫∑t test v√†o th∆∞ m·ª•c `backend/services/security/tests/` (v√≠ d·ª•: `tests/test_tokenization.py`, `tests/test_fraud_detection.py`, ...).  
- M·ªôt s·ªë test c·∫ßn mock AWS (HSM/KMS) ‚Äî d√πng `moto` ho·∫∑c mocking th·ªß c√¥ng.

1) C√†i dev dependencies (local):
- T·∫°o virtualenv r·ªìi c√†i:
  - Windows:
    - python -m venv .venv
    - .venv\Scripts\activate
  - Unix/macOS:
    - python -m venv .venv
    - source .venv/bin/activate
- C√†i pytest v√† c√¥ng c·ª• h·ªØu √≠ch:
  - pip install -U pytest pytest-asyncio httpx moto coverage

2) C·∫•u tr√∫c test (g·ª£i √Ω)
- backend/services/security/tests/
  - test_tokenization.py
  - test_fraud_detection.py
  - test_encryption.py
  - test_three_d_secure.py
  - test_pci_auditor.py
  - test_hsm_client.py  (n·∫øu d√πng moto ƒë·ªÉ mock KMS)

3) V√≠ d·ª• l·ªánh ch·∫°y:
- Ch·∫°y to√†n b·ªô tests:
  - pytest -q
- Ch·∫°y tests trong th∆∞ m·ª•c security:
  - pytest backend/services/security/tests -q
- Ch·∫°y m·ªôt file c·ª• th·ªÉ:
  - pytest backend/services/security/tests/test_tokenization.py -q
- Ch·∫°y 1 test c·ª• th·ªÉ:
  - pytest backend/services/security/tests/test_tokenization.py::test_generate_token -q
- Ch·∫°y k√®m coverage:
  - coverage run -m pytest && coverage report -m

4) G·ª£i √Ω vi·∫øt test nhanh (v√≠ d·ª• n·ªôi dung file):
- test_tokenization.py (v√≠ d·ª•)
  - Ki·ªÉm tra Luhn validation, generate_token tr·∫£ mask + token, detokenize ho·∫°t ƒë·ªông.
- test_fraud_detection.py
  - T·∫°o TransactionInput v·ªõi amount cao/low ƒë·ªÉ assert risk levels v√† triggered rules.
- test_encryption.py
  - Encrypt/decrypt v·ªõi FieldEncryption v√† AESEncryption (s·ª≠ d·ª•ng master key t·ª´ env mock).
- test_hsm_client.py
  - N·∫øu d√πng moto ƒë·ªÉ mock KMS, mark test v·ªõi moto.mock_kms.

5) Test ch·∫°y trong Docker (t√πy ch·ªçn)
- N·∫øu d·ª± √°n ch·∫°y trong container, build image dev ho·∫∑c ch·∫°y pytest trong container mount source:
  - docker run --rm -v %cd%:/app -w /app python:3.11-slim bash -c "pip install pytest moto && pytest backend/services/security/tests -q"

6) L∆∞u √Ω b·∫£o m·∫≠t khi test
- Kh√¥ng commit secret th·∫≠t (.env ch·ª©a Key_AES/Stripe keys). D√πng bi·∫øn m√¥i tr∆∞·ªùng test ho·∫∑c file .env.test.
- Kh√¥ng log PAN/CVV trong test output.

7) CI (GitHub Actions) - v√≠ d·ª• job ƒë∆°n gi·∫£n
- steps:
  - Checkout
  - Set up Python
  - Install deps
  - Run pytest backend/services/security/tests -q
  - (Optional) upload coverage

K·∫øt th√∫c ‚Äî b·∫°n c√≥ th·ªÉ th√™m v√≠ d·ª• test files theo m·∫´u tr√™n v√†o `backend/services/security/tests/` r·ªìi ch·∫°y c√°c l·ªánh pytest n√™u ·ªü tr√™n.